# Task: NetworkClient Implementation

## Objective
Create the main NetworkClient class that orchestrates all networking operations.

## Context
- Related files:
  - `Sources/NetKit/Core/NetworkClient.swift`
- Dependencies: ALL previous tasks (001-008)
- Branch: `feature/network-client`

## Steps
1. [ ] Create `NetworkClient.swift` as `final class`
2. [ ] Implement initializer:
   - `environment: Environment`
   - `interceptors: [Interceptor] = []`
   - `retryPolicy: RetryPolicy? = nil`
   - `cache: ResponseCache? = nil`
3. [ ] Implement `request<E: Endpoint>(_ endpoint: E) async throws -> E.Response`
4. [ ] Build URLRequest from endpoint + environment
5. [ ] Run request interceptors (in order)
6. [ ] Execute URLSession request
7. [ ] Run response interceptors (in reverse order)
8. [ ] Handle HTTP status codes → NetworkError mapping
9. [ ] Decode response (skip for EmptyResponse)
10. [ ] Implement retry logic using RetryPolicy
11. [ ] Implement cache check/store logic
12. [ ] Add method returning RequestBuilder for fluent API

## Acceptance Criteria
- [ ] Conforms to NetworkClientProtocol
- [ ] Supports simple `request()` call
- [ ] Supports fluent `request().timeout().header().send()` pattern
- [ ] Runs interceptors in correct order
- [ ] Handles EmptyResponse without decoding
- [ ] Maps HTTP status codes to NetworkError
- [ ] Retries according to policy
- [ ] Caches responses when cache is configured
- [ ] Thread-safe (Sendable)

## Notes
- Use URLSession.shared or allow custom session injection
- EmptyResponse detection: check if Response == EmptyResponse.self
- Status code mapping: 401→unauthorized, 403→forbidden, 404→notFound, 5xx→serverError
- Consider making client an actor for thread safety
